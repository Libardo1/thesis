\section{Моделиране}
	
	След анализът върху съществуващите симулационни системи изглежда, че
	система която да реши поставените проблеми не съществува.
	Повечето от тях имат примитивни \ac{GUI} които не предоставят
	необходимата гъвкавост на точно определена създадена за целта такава.
	
	Под голям въпрос е и качеството на документацията, както и състоянието на
	наличните примери и качество на кода. Това оставя възможността да бъде разгледан
	един нетрадиционен вариант за решаване на такъв проблем.
	
	За създаването на нашият модел и цялостната програма ще се използва итеративен подход \cite{ArtOfAgile}.
	Това означава, че ще изградим основните части от системата - 
	първо\footnote{Посоченият подход е лична интерпретация}. Допълнителна 
	функционалност ще добавяме само, когато сме доволни от качеството на текущата програма. 
			
	Основната част от програмата ще контролира заложените закони и взаимодеиствия	между обектите.
	При всяка нова стъпка от симулацията, обектите участващи в нея ще предоставят информация за
	състоянието в което се намират. То може да се променя, като това е изразено в промяна
	на техните свойства.
	
	Необходимостта за изобразяване на самата симулация, по време на изпълнение и когато тя вече е приключила,
	води до някои допълнителни ограничения. Системата трябва да работи достатъчно бързо\footnote{Между 30 и 60 кадъра в секунда},
	за да предоставя гладка и лека работа за потребителя.
	
	С така поставените ограничения и подходи, използването на \ac{DES} предоставя:
	
	\begin{itemize}
		\item Гъвкавкост
		
		\item Лесна имплементация
		
		\item Лесна промяна
		
		\item Лесно скриване на детайлите от самия потребител	
				
	\end{itemize}				
	
	Още повече, за симулация на трафик е необходима симулация от тип опашка, която в повече от случаите
	се имплементира с помощта на \ac{DES} \cite{Barlas}.
	
	За настройка на симулацията, потребителя ще трябва да отвори и промени конфигурационен файл. 
	Когато симулацията започне, на потребителя се дава възможност визуално
	да наблюдава симулацията на всяка своя стъпка. След приключването й се предоставят
	данни за това как е протекла симулацията.	На фиг. \ref{figure:system-model} е изобразена диаграма, която показва
	работата на така зададения модел.		
	
	\begin{figure} 
			\caption{Модел на симулационната система}
			\label{figure:system-model}
			\begin{center}
			
				\begin{tikzpicture}[scale=2, node distance = 4cm, auto]
				    % Place nodes
				    \node [start] (init) {Начало};
				    \node [block, below of=init, node distance = 4cm] (load-settings) {Зареждане на настройки};
				    \node [block, right of=load-settings, node distance = 5cm] (next-step) {Преминаване към следващо състояние};
				    \node [block, below of=next-step, node distance = 3cm] (draw-current-state) {Изобразяване на текущото състояние};
				    \node [decision, below of=draw-current-state, node distance = 5cm] (is-end) {Приключила ли е симулацията?};
				    \node [block, below of=is-end, node distance = 5cm] (results) {Показване на крайните резултати};
				    \node [exit, left of=results, node distance = 5cm] (end) {Край};
				    % Draw edges
				    \path [line] (init)               -- (load-settings);
				    \path [line] (load-settings)      -- (next-step);
				    \path [line] (next-step)          -- (draw-current-state);
				    \path [line] (draw-current-state) -- (is-end);
				    \path [line] (is-end.east)        |- node[above right] {Не} (next-step.east);
				    \path [line] (is-end)             -- node[midway] {Да} (results);
				    \path [line] (results)            -- (end);
				\end{tikzpicture}	
		
		\end{center}	
		
	\end{figure}						
	\newpage
	
	\subsection{Компоненти на симулацията}
		Една \ac{DES} се представя като поредица от случващи се събития. Всяко събитие в
		определен момент и поражда промяна на състоянието на системата. 
		
		\subsubsection{Основни изграждащи единици}	
			Всяка \ac{DES} се нуждае от логика, която да отговаря на това какво се прави, когато
			дадено събитие се случи. Трябва и да се определят точните времена в които те ще се случат.
			Някои други компоненти, обаче, също са задължителни:
			
			\begin{description}
			
				\item[Часовник] грижи се за запазването и променянето на текущото време за симулацията.
				Единиците в които времето се измерва се избират спрямо самата симулация.
				Благодарение на незабавното случвания на събитията, времето подскача (hops).
				
				\item[Участници в симулацията] са конкретни обекти, които взаимодействат със други такива и 
				влият пряко на резултатите на изпълнение. Определянето на това, какви точно трябва да бъдат те,
				зависи изцяло от модела. Тяхното количество в точно определен момент на симулацията,
				зависи от входните данни, както и текущата стъпка.
				
				\item[Списък на събитията] представлява подредено множество от събития, които още не били
				изпълнени. Много от тях не са предварително дефинирани, а са създадени в следствие на
				изпълнение на предшестващи ги събития. Събитие е описано чрез тип и време на случване. 
				
				Понякога е необходимо да изпълняваме различни задачи, които се простират извън границите
				на един момент от времето. Обикновено това се моделира като поредица от събития.
				Те биват създвани като се използва диапазон от време.
				
				Системата може да поддържа еднонишково(singnle-threaded) и\\
				многонишково(multi-threaded) изпълнение на събития в даден момент. 
				При вторият вид може да се породят проблеми със 
				синхронизацията между различните участници в симулацията. От друга страна,
				той допринася за по-бързото й представяне на потребителя.
				
				За имплементация на списъка със събития се използва приоритетна опашка. Приоритетът е
				времето за случване на събитието. Няколко алгоритъма за създаване на приоритетни опашки
				са се доказали като подходящи при създаването на \ac{DES}\cite{Jones}, най-вече ``разширено дърво``(splay tree).
				
				\item[Случайни числа] се използват за различни нужди по време на изпълнение на симулацията.
				Тя се нуждае от случайно генерирани променливи, в зависимост от модела. 
				Използват се псевдо-случайни числа, вместо случайни числа, за да се използват
				еднакви данни когато искаме да проведем симулация с еднакво поведение.				
				
				\item[Статистики] се събират по време на изпълнение на симулацията. Тяхното естество, отново, е зависимо от модела
				на симулацията. Те представляват данните, който потребителя вижда след края на всяка симулация.				
				
				\item[Условие за край] е това, което трябва да е изпълнено за да приключи симулацията. 
				При отсъствие на такова, теоретично, една симулация може да продължи безкрайно.
				Създателят на симулацията трябва да прецени какво точно да бъде то, 
				за да може тя да бъде прекратена.
				
			\end{description}
			
	\subsection{Архитектура}
		\label{sec:architecture}
		
		За да предостави възможност за лесно развитие и промяна на стратегиите за оптимизация, системата
		трябва да бъде лесно разширима и да базира работата си на интерфейси, а не конкретни имплементации.
		Това води до нуждата от създаването на интерфейс. Един задължителен такъв е модел. 
		
		Моделите се създават като преизползват вече съществуващи части и поведения от системата. 
		Големите модели се създават като множество от други модели, някои от които са атомарни.
		Атомарните модели не могат бъдат композирани от по-малки такива. Те съдържат поведението
		на отделните елементи в симулацията.
		
		Симулационният двигател работи като използва интерфейсите на двата вида модели. Това му позволява
		да се фокусира върху създаването на стратегии за симулация, обявяване на събития и други задачи.
		
		Визуализацията, взаимодействието и други функционалности са отговорности на софтуера който използва 
		симулационният двигател. Този софтуер се нарича \emph{симулационнен клиент}. Той контролира
		как времето в симулацията напредва, като това може да е подобно на нормално течащото време или
		по някакъв друг зададен подход. Клиентът бива оведомяван, когато някой модел промени състоянието си
		и има нужда да бъде обновен на потребителския екран, събрана статистика, отстранена грешка и др.
		Последната основна роля на клиентът е възможност за събиране на данни от потребителя и предоставянето
		им като вход на симулационния двигател.
		
		Симулационният двигател за създаване на \ac{DES} е най-лесният за имплементиране. Разширяването му
		до по-сложна система за симулации е лесно, щом основните компоненти на двигателя са създадени.
		Структурата на работа остава постоянна, създават се смесени и атомарни компоненти, които се
		използват при самото осъществяване на самата симулация. Симулациите основно се различават според
		алгоритъма по който времето напредва по време на симулацията.
		
		\subsubsection{Атомарни модели}
			
			Атомичният модел е динамична система, която се променя спрямо обграждащата я среда.
			Промените в самия модел се отразяват и на обграждащата го среда. Съществува
			множество от входни променливи, които имат ефект върху модела - \emph{X}. Множество от изходни променливи, 
			които влияят на обграждащата го среда - \emph{Y}. Състонието на системата се съдържа в множество
			от променливи - \emph{S}.
			
			Променливото поведение на системата е описано като функции от време до входни, изходни и множества, описващи
			състоянието. Множеството от времена, използвани от системата, е наречено база за времето (time base) и се бележи с N.
			
			\emph{Траекториите} биват три вида - входни, изходни и такива, обвързани със промяна на състоянието.
			Всеки вид съответства на \emph{X}, \emph{Y} и \emph{S}. Стойността на траекторията \emph{z} в специфично време \emph{t} се записва
			като \emph{z(t)}.
			
			Траекториите се се дефинират в интервал от време и се отбелязват като $z<t_0, t_n>$ , в общия случай. За прецизиране
			на интервалите се използват стандарните математически интервали т.е.
			
			\begin{equation}
			\begin{split}
				t \in [t_0, t_n] \Longleftrightarrow t_0 \le t \le t_n\\
				t \in (t_0, t_n] \Longleftrightarrow t_0 < t \le t_n\\
				t \in [t_0, t_n) \Longleftrightarrow t_0 \le t < t_n\\
				t \in (t_0, t_n) \Longleftrightarrow t_0 < t < t_n
			\end{split}
			\end{equation}
			
			\emph{Промяна на състоянието} се осъществява чрез цялостната функция $\Delta$, която премества системата от \emph{s} до
			$s\prime$ като отговор на входната траектория $x[t_0, t_n)$
			
			\begin{equation}
				s\prime = \Delta(s, x[t_0, t_n))
			\end{equation}
			
			Не всички такива функции са цялостни, $\Delta$ трябва да удовлетворява
			
			\begin{equation}
				\Delta(s, x_1 \bullet x_2) = \Delta(\Delta(s, x_1), x_2)
			\end{equation}
			
			\begin{equation}\label{no-empty-interval}
				\Delta(s, x[t_0, t_n)) = s
			\end{equation}
			
			Уравнение \eqref{no-empty-interval} изисква от системата да не променя състоянието си
			в празен интервал от време. Практически е много полезно да се изисква
			
			\begin{equation}\label{no-time-dependant}
				\Delta(s, t(h, x)) = \Delta(s, x)
			\end{equation}
			
			Уравнение \eqref{no-time-dependant} показва, че реакцията на системата, при зададен вход, не зависи
			от времето в който е бил даден той.
			
			\begin{algorithm}				
				\caption{Итеративна процедура за изчисление на функцията за промяна на състоянието}				
				\label{algorithm:state-transition}
				\begin{algorithmic}
					\State $s\gets s_0$
					\For{$t_k = t_0 \to t_n$}
						\State $print(t_k, s)$
						\Comment{Изписва на екрана времето и текущото състояние}
						\State $s\gets F(s, x(t_k))$
					\EndFor
				\end{algorithmic}
			\end{algorithm}
			
		\subsubsection{Смесени модели}
		
		Този вид модели се състоят от две части: множеството от компоненти, от които е изграден и описание
		на връзките между модела и съдържащите се в него модели. Изходът от смесените модели
		може да бъде свързан като вход за други компоненти. Входът за самия модел може да бъде вход за
		неговите вложени компоненти.
		
		Смесените модели, също както и атомарните, имат множество от входни данни \emph{X} и множество
		от изходни данни \emph{Y}. Мрежата от модели има ролята на входна траектория, която създава изходна такава.
		Промяната от входни до изходни данни се извършва от вложените компоненти. Тяхното общо състояние определят
		и цялостното състояние на мрежата. Функцията за промяна на състоянието е дефинирана като функция от
		функциите за промяна на състоянието на отделните компоненти. Изходната функция има същата дефиниция.
		
		Смесеният модел е запознат само с входа и изхода на вложените в него компоненти. Вътрешната имплементация
		на отделните модели е скрита. Това води до възможността, всеки смесен модел да бъде представен като атомарен
		такъв, който точно препокрива начинът му на действие.
		
		За да се даде ясна дефиниция на резултатът получен от смесен модел е необходимо точно описание
		на неговите части. Самият модел се записва с \emph{N}. Има множество от 
		входни данни - \emph{X} и изходни данни - \emph{Y}. Множеството \emph{D} съдържа всички компоненти на модела.
		За всеки модел $d \in D \bigcup {U}$ има множество от компоненти, които оказват влияние върху \emph{d}.
		
		Различните части на смесените модели са:
		
		\begin{itemize}
			\item $X_n = $ входно множество
			\item $Y_n = $ изходно множество
			\item $D_n = $ множество от компоненти
		\end{itemize}
		
		\emph{Резултантна на смесен модел} е атомарен модел, който се представя като мрежа от модели.
		Той има множество $S_r$ от състояния, $X_R$ множество от входни данни, $Y_r$ множество от изходни данни,
		$\delta_r$ функция за промяна на състоянието и $\lambda_r$ изходна функция.
		
		Множеството от състояния на резултантната се създава рекурсивно с функцията \emph{State}.
		Тази функция приема като аргумент модел и връща множество от състоянията му. В зависимост
		от типа на подадения модел, тя може да върне множество на атомарен модел или продукт
		от множествата на смесен модел. Функцията може да бъде изразена по следния начин
			
		\[
		  STATE(d) = \left\{ 
		  \begin{array}{l l}
		    S_d & \quad \text{ако $d$ е атомарен модел}\\
		    X_d \prime \in D_d & \quad \text{ако $d$ е смесен модел}\\
		  \end{array} \right\}
		\]
		
		\noindent Множеството от състояния на резултантата на смесения модел \emph{N} е
		
		\begin{equation}
			S_r = STATE(N)
		\end{equation}
		
		\noindent и резултантата и смесения модел има еднакви входно-изходни множества
		
		\begin{equation}
			X_r = X_n
		\end{equation}		
		\begin{equation}
			Y_r = Y_n
		\end{equation}
		
		Това множество от дефиниции за създаване на атомарен модел е достатъчно
		за създаване на двигател за симулации. Въпреки това, софтуерът ще бъде
		организиран и реализиран по различен начин. Сравнително простите
		дефиниции ни показват какво трябва да върши един двигател за симулации,
		не точно как да го прави. От части, всяка \ac{DES} е идентична, два
		симулатора с еднакви подадени модели като входни данни, трябва да
		предоставят идентични изходни входни данни,
					
\section{Реализация}

	За да се спази итеративния подход към създаването на системата,
	по време на първата итерация, се имплементират само някои от изискванията към системата. 
	Също така, тези изисквания може допълнително да бъдат разбити на по-малки такива.
	
	Първата версия има малък набор от функционалности, които, според автора, имат най-висок приоритет за
	изграждането на работеща програма, която може да бъде разширена лесно и бързо
	чрез минимални познания по системата и редове код.
	Версията има следната функционалност:
	\begin{itemize}
		\item Симулацията представлява пътно кръстовище с 4 посоки на движение.
		\item Всяка посока има само 1 пътно платно.
		\item Превозните средства могат да се движат само направо.
		\item Скоростта за движение е постоянна.
	\end{itemize}
	
	Посочените опростявания ще ни позволят да намерим грешките, които сме допуснали
	при създаването на предварителния модел на системата. Още повече, 
	те ще ускорят създаването на първоначална версия на системата.
	
	\subsection{Итерация I}
	
		След оглед на по-горе посочените необходими функционалности се забелязва необходимостта от 
		изграждане на проста и гъвката архитектура, която да ни позволи по-лесно добавяне на нови възможности. 
		Добавянето на нови такива е задължително, поради избора на начинът на разработка на симулационния софутер. 		
		
		Опростенията, които бяха избрани, допълнително правят задачата по-бърза за имплементиране,
		но не трябва да се забравя, че те са само временни и задължително трябва да бъдат премахати
		в следващи фази от разработката. Така, начинът по който създаваме архитектурата
		на системата, не трябва да зависи от детайлите на специфичните за първата итерация
		възможности, а да разчита на по-абстрактната архитектура, описана в \ref{sec:architecture}.
		
		За целите на първата итерация, имплементираната архитектура е зададена като клас диаграма на фиг. \ref{figure:simulation-class-diagram}.
		Представени са само основните класове, за да се представи основната идея на имплементацията, без
		да се разглеждат детайли обвързани с изобразяването на отделните обекти и конкретни имплементации.
		
		\begin{figure}
			\caption{Клас диаграма на симулационната система}
			\label{figure:simulation-class-diagram}
				\begin{center}
					\begin{tikzpicture}
						\begin{class}[text width = 6cm]{Simulator}{-5, 0}
							\operation{+ start(state)}
						\end{class}
						
						\begin{class}[text width = 7cm]{Timer}{3, 0}
							\attribute{- seconds}
							\operation{+ start()}
							\operation{+ advance()}
							\operation{+ elapsedSeconds() : seconds}
						\end{class}					
						
						\begin{class}[text width = 7cm]{State}{-5, -6}
							\attribute{- models}
							\attribute{- strategy}
							\operation{+ onStart()}
							\operation{+ onNextStep(elapsedSeconds)}
							\operation{+ setCompleteCallback(callback)}
						\end{class}
					
						\begin{class}[text width = 7cm]{Strategy}{3, -6}
							\operation{+ decide(elapsedSeconds, models)}
						\end{class}					
																				
						\begin{class}{Model}{3, -12}
							\attribute{- x}
							\attribute{- y}
							\attribute{- targetX}
							\attribute{- targetY}
							\attribute{- orientation}
							\operation{+ draw()}
							\operation{+ move()}
						\end{class}
																		
					\end{tikzpicture}
				\end{center}
		\end{figure}
		
		\newpage
		
		Представената архитектура използва краен автомат за промяна на текущото състояние.
		Това много напомня на начинът по който се създава дизайн и имплементация за мобилни, настолни
		и др. видове игри. Концепция, доказала се при създаването на множество успешни видео игри. 
		Тук, разбира се, тя е по-проста и олекотена, но запазва добрата основа, 
		върху която може да бъде изградена по-сложен софтуер. По-обстойно, подобна архитектура е описана в \cite{Rollings}.
		

		\subsubsection{Симулатор}		
		
		В основата на симулацията е класът \emph{Simulator}. Неговата задача е да стартира симулацията
		и инициализира правилно началното състояние. За да направи това е нужен и часовник, който се грижи
		за поддържане на изминалото време от началото на симулацията. 
		
		Когато текущото състояние приключи своята работа, симулацията трябва да предаде контролът върху следващото или да прекрати работата
		на програмата. Комуникацията се извършва чрез съобщение (и по-точно указател към функция), което
		се изпраща на симулацията, когато текущото състояние приключи работата си. Така, симулаторът,
		се грижи за стартиране на текущото състояние и стартиране на следващо, когато това се наложи.
		
		Описаният по-горе часовник, като компонент на симулацията, базира времето си
		на изминалите кадри. Това е така, защото не е ясно дали компютърната система
		на която тече симулацията може да поддържа оптимилания брой кадри за секунда.
		Алгоритъмът е показан на алг. \ref{algorithm:elapsed-seconds}.

		\begin{algorithm}				
			\caption{Засичане на изминало време в симулацията}				
			\label{algorithm:elapsed-seconds}
			\begin{algorithmic}
				\If {$frames \bmod 60 = 0$}
					\State $seconds\gets seconds+1$
					\State $notifySystemTimeChange(seconds)$
				\EndIf
			\end{algorithmic}
		\end{algorithm}
		
		\subsubsection{Състояние}					
		
		\emph{State} представя едно текущо състояние от симулация. То има няколко основни момента от своето съществуване.
		 
		Когато бъде стартирано се извиква метода \emph{onStart()}. Той има за цел да инициализира текущото състояние и да го приготви за работа.
		Извиква само толкова пъти, колкото състоянието се стартира. 
		
		Методът \emph{onNextStep()} се извиква, когато симулацията е напреднала 
		с една стъпка. Като аргумент се предава времето, което е изминало от стартирането на симулацията. 
		Методът се извиква \emph{n} пъти, където n е броят стъпки на симулацията. 
		
		\emph{onFinish()} се извиква, когато състоянието се прекратява. Възможно е да се премахне този метод и 
		всяко състояние да отговаря за приключването си, само. Това би направило невъзможно
		прекратяване на текущо състояние от симулацията и добавяне на допълнителни условия за приключване. 
		Ефекти, които е добре да се избегнат. Въпреки това, има необходимост от начин за прекратяване на по-нататъшно обработване
		на текущото състояние. Така всяко състояние ще може да капсулира логиката за прекратяването си. Механизмът
		за това е извикване на метода \emph{finish()}.
		
		\subsubsection{Стратегия}
		
		Този интерфейс е имплементация на шаблона за дизайн \emph{Strategy} от книгата \cite{Gamma}, 
		пригоден за нуждите на системата. Той предоставя основна точка за разширение на начинът
		по който симулацията може да работи.
		
		Единственият важен метод е \emph{decide()}. Той приема, като аргументи, текущото време и участващите модели.
		Негова задача е да определи кога и кои модели, участващи в симулацията, ще извършат определени действия.
		
		Имплементацията на този интерфейс може да се променя лесно. Това става чрез създаването на нова, отговаряща
		на нуждите на новите изисквания и промяна на конфигурационна настройка.

		\subsubsection{Модел}		
		
		\emph{Model} има за цел да предостави интерфейс на атомарен или сложен модел. Основно
		звено в симулационната система.		
		
		Методът \emph{draw()} се използва за изчертаване на модела върху екрана. Той използва
		предварително зададените атрибути - начална позиция, крайна позиция и ориентация за
		да се изобрази правилно. Знанието на всеки модел за начинът на собственото си изчертаване
		е опростяване на имплементацията, което в тази фаза от разработката не противоричи
		на избраната абстракция.
		
		Методът \emph{move()} се извиква, когато текущата стратегия реши, че точно този модел
		трябва да изпълни някакво действие. За нуждите на текущата реализация, той кара
		различните обекти да се придвижват, но върху това лесно може да бъде надградено,
		когато изискванията станат по-сложни.
