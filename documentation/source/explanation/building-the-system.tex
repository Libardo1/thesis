\section{Реализация}

	За да се спази итеративния подход към създаването на системата,
	по време на първата итерация се имплементират само някои от изискванията към системата. 
	Също така, тези изисквания може допълнително да бъдат разбити на по-малки такива.
	
	Първата версия има малък набор от функционалности, които, според автора, имат най-висок приоритет за
	изграждането на работеща програма, която може да бъде разширена лесно и бързо
	чрез минимални познания по системата и редове код.
	Версията има следната функционалност:
	\begin{itemize}
		\item Симулацията представлява пътно кръстовище с 4 посоки на движение.
		\item Всяка посока има само 1 пътно платно.
		\item Превозните средства могат да се движат само направо.
		\item Скоростта за движение е постоянна.
	\end{itemize}
	
	Посочените опростявания ще ни позволят да намерим грешките, които сме допуснали
	при създаването на предварителния модел на системата. Още повече, 
	те ще ускорят създаването на първоначална версия на системата.
	
	\subsection{Итерация I}
	
		След оглед на по-горе посочените необходими функционалности се забелязва необходимостта от 
		изграждане на проста и гъвката архитектура, която да ни позволи по-лесно добавяне на нови възможности. 
		Добавянето на нови такива е задължително, поради избора на начина на разработка на симулационния софутер. 		
		
		Опростенията, които бяха избрани, допълнително правят задачата по-бърза за имплементиране,
		но не трябва да се забравя, че те са само временни и задължително трябва да бъдат премахнати
		в следващи фази от разработката. Така начинът, по който създаваме архитектурата
		на системата, не трябва да зависи от детайлите на специфичните за първата итерация
		възможности, а да разчита на по-абстрактната архитектура, описана в \ref{sec:architecture}.
		
		За целите на първата итерация, имплементираната архитектура е зададена като клас диаграма на фиг. \ref{figure:simulation-class-diagram}.
		Представени са само основните класове, за да се представи основната идея на имплементацията, без
		да се разглеждат детайли, обвързани с изобразяването на отделните обекти и конкретни имплементации.
		
		\begin{figure}
			\caption{Клас диаграма на симулационната система}
			\label{figure:simulation-class-diagram}
				\begin{center}
					\begin{tikzpicture}
						\begin{class}[text width = 6cm]{Simulator}{-5, 0}
							\operation{+ start(state)}
						\end{class}
						
						\begin{class}[text width = 7cm]{Timer}{3, 0}
							\attribute{- seconds}
							\operation{+ start()}
							\operation{+ advance()}
							\operation{+ elapsedSeconds() : seconds}
						\end{class}					
						
						\begin{class}[text width = 7cm]{State}{-5, -6}
							\attribute{- models}
							\attribute{- strategy}
							\operation{+ onStart()}
							\operation{+ onNextStep(elapsedSeconds)}
							\operation{+ setCompleteCallback(callback)}
						\end{class}
					
						\begin{class}[text width = 7cm]{Strategy}{3, -6}
							\operation{+ decide(elapsedSeconds, models)}
						\end{class}					
																				
						\begin{class}{Model}{3, -12}
							\attribute{- x}
							\attribute{- y}
							\attribute{- targetX}
							\attribute{- targetY}
							\attribute{- orientation}
							\operation{+ draw()}
							\operation{+ move()}
						\end{class}
																		
					\end{tikzpicture}
				\end{center}
		\end{figure}
		
		\newpage
		
		Представената архитектура използва краен автомат за промяна на текущото състояние.
		Това много напомня на начина, по който се създава дизайн и имплементация за мобилни, настолни
		и др. видове игри. Концепция, доказала се при създаването на множество успешни видео игри. 
		Тук, разбира се, тя е по-проста и олекотена, но запазва добрата основа, 
		върху която може да бъде изграден по-сложен софтуер. По-обстойно, подобна архитектура е описана в \cite{Rollings}.
		

		\subsubsection{Симулатор}		
		
		В основата на симулацията е класът \emph{Simulator}. Неговата задача е да стартира симулацията
		и инициализира правилно началното състояние. За да направи това, е нужен и часовник, който се грижи
		за поддържане на изминалото време от началото на симулацията. 
		
		Когато текущото състояние приключи своята работа, симулацията трябва да предаде контрола върху следващото или да прекрати работата
		на програмата. Комуникацията се извършва чрез съобщение (и по-точно указател към функция), което
		се изпраща на симулацията, когато текущото състояние приключи работата си. Така, симулаторът,
		се грижи за стартиране на текущото състояние и стартиране на следващо, когато това се наложи.
		
		Описаният по-горе часовник, като компонент на симулацията, базира времето си
		на изминалите кадри. Това е така, защото не е ясно дали компютърната система,
		на която тече симулацията може да поддържа оптимилания брой кадри за секунда.
		Алгоритъмът е показан на алг. \ref{algorithm:elapsed-seconds}.

		\begin{algorithm}				
			\caption{Засичане на изминало време в симулацията}				
			\label{algorithm:elapsed-seconds}
			\begin{algorithmic}
				\If {$frames \bmod 60 = 0$}
					\State $seconds\gets seconds+1$
					\State $notifySystemTimeChange(seconds)$
				\EndIf
			\end{algorithmic}
		\end{algorithm}
		
		\subsubsection{Състояние}					
		
			\emph{State} представя едно текущо състояние от симулация. То има няколко основни момента от своето съществуване.
			 
			Когато бъде стартирано, се извиква методът \emph{onStart()}. Той има за цел да инициализира текущото състояние и да го приготви за работа.
			Извиква се само толкова пъти, колкото състоянието се стартира. 
			
			Методът \emph{onNextStep()} се извиква, когато симулацията е напреднала 
			с една стъпка. Като аргумент се предава времето, което е изминало от стартирането на симулацията. 
			Методът се извиква \emph{n} пъти, където n е броят стъпки на симулацията. 
			
			\emph{onFinish()} се извиква, когато състоянието се прекратява. Възможно е да се премахне този метод и 
			всяко състояние да отговаря за приключването си, само. Това би направило невъзможно
			прекратяване на текущо състояние от симулацията и добавяне на допълнителни условия за приключване. 
			Ефекти, които е добре да се избегнат. Въпреки това, има необходимост от начин за прекратяване на по-нататъшно обработване
			на текущото състояние. Така всяко състояние ще може да капсулира логиката за прекратяването си. Механизмът
			за това е извикване на метода \emph{finish()}.
		
		\subsubsection{Стратегия}
		
			Този интерфейс е имплементация на шаблона за дизайн \emph{Strategy} от книгата \cite{Gamma}, 
			пригоден за нуждите на системата. Той предоставя основна точка за разширение на начина,
			по който симулацията може да работи.
			
			Единственият важен метод е \emph{decide()}. Той приема, като аргументи, текущото време и участващите модели.
			Негова задача е да определи кога и кои модели, участващи в симулацията, ще извършат определени действия.
			
			Имплементацията на този интерфейс може да се променя лесно. Това става чрез създаването на нова, отговаряща
			на нуждите на новите изисквания и промяна на конфигурационна настройка.

		\subsubsection{Модел}		
		
			\emph{Model} има за цел да предостави интерфейс на атомарен или сложен модел. Основно
			звено в симулационната система.		
			
			Методът \emph{draw()} се използва за изчертаване на модела върху екрана. Той използва
			предварително зададените атрибути - начална позиция, крайна позиция и ориентация за
			да се изобрази правилно. Знанието на всеки модел за начина на собственото си изчертаване
			е опростяване на имплементацията, което в тази фаза от разработката не противоричи
			на избраната абстракция.
			
			Методът \emph{move()} се извиква, когато текущата стратегия реши, че точно този модел
			трябва да изпълни някакво действие. За нуждите на текущата реализация, той кара
			различните обекти да се придвижват, но това лесно може да бъде надградено,
			когато изискванията станат по-сложни.
		
	\subsection{Итерация II}
		
		След имплементиране на всички функционалности, изисквани от първата итерация, е ред да се изберат
		следващите по-важни такива.
		
		Нова функционалност:
		\begin{itemize}
			\item Представяне на статистика и различни метрики от проведената симулация.
			\item Моделите се подреждат на случаен принцип в опашки.
			\item Лесна конфигурация на системата.
			\item Приоритизиране на отделни модели
		\end{itemize}
		
		Последното от изискванията може да бъде лесно удовлетворено, чрез създаване на специфична стратегия,
		която да следи за текущите модели, които са в различните опашки. Примерна стратегия, даваща висок
		приоритет на автобуси от градския транспорт, е изградена във файла \emph{bus-priority.lua}.
		
		За целите на втората итерация, имплементираната архитектура е зададена като клас диаграма на фиг. \ref{figure:simulation-class-diagram-two}.
		На диаграмата са представени само нови/променени класове. Особено впечатление прави запазването на основните класове и методи. 
		Добавят се нови методи и параметри за предишни такива.	Добавени са два нови, основни, класа. \emph{Queue} - поддържа моделите
		в опашка и \emph{UiFactory} - отговаря за изчертаването на различните елементи върху потребителския екран.		
		
		\begin{figure}
			\caption{Клас диаграма на новите елементи след 2-рата итерация}
			\label{figure:simulation-class-diagram-two}
				\begin{center}
					\begin{tikzpicture}
						\begin{class}[text width = 6cm]{Queue}{-5, 0}
							\attribute{- data}
							\operation{+ push(item)}
							\operation{+ isEmpty()}
							\operation{+ pop()}
							\operation{+ peek()}
							\operation{+ size()}
						\end{class}
						
						\begin{class}[text width = 7cm]{UiFactory}{3, 0}
							\operation{+ drawTextBox(options)}
							\operation{+ drawImage()}
							\operation{+ drawLayer()}
							\operation{+ drawModel(model)}
							\operation{+ moveAndRemove(model, onCompleteCallback)}
							\operation{+ clearScreen()}
						\end{class}					
						
						\begin{class}[text width = 7cm]{State}{-5, -6}
							\attribute{- models}
							\attribute{- strategy}
							\operation{+ onStart(parameters)}
							\operation{+ onNextStep(elapsedSeconds)}
							\operation{+ setListener(listener)}
						\end{class}
					
						\begin{class}[text width = 7cm]{Strategy}{3, -6}
							\operation{+ decide(elapsedSeconds)}
							\operation{+ setListener(listener)}							
						\end{class}																		
					\end{tikzpicture}
				\end{center}
		\end{figure}
		
		\subsubsection{Състояние}
			
		В класът \emph{State} са добавени механизми за предаване на параметри между различните състояния и лесен начин за изпращане
		на съобщения, за всички, които се интересуват от тях. И двата проблема са разрешени с помощта на указатели към методи/функции.
		За избиране на следващото активно състояние се грижи текущото такова.

		Подреждането на моделите и тяхното създаване е грижа на състоянието, което работи с тях. 
		Статистиката от проведената симулация се събира и предава на следващото състояние.
		Показването на статистиките става в ново състояние, което получава като параметри всички метрики, чрез механизма описан по-горе.
		
		
		\subsubsection{Опашка}
		
		В езика \emph{Lua}, имплементация на \emph{FIFO} структура от данни не съществува. Направената имплементация
		е стандартна с малко изключение. Вместо \emph{nil}, когато в опашката няма следващи елементи, тя връща, като резултат, 
		обект от тип \emph{Optional}. Този обект може да има стойности по подразбиране и да бъде проверяван за това дали 
		съдържа стойност или не. Това има много предимства, които са довели специалисти от \emph{Google} да 
		създадат подобен клас за своята библиотека
		\emph{Guava\footnote{\url{http://code.google.com/p/guava-libraries/}}}. От там идва и идеята за имплементацията в системата.
		
		\subsubsection{Фабрика за Графични Елементи}
		
		За изграждане на \ac{GUI} е необходимо писането на специфичен код, който се грижи за изобразяване на различни елементи
		върху екрана. Класът \emph{UiFactory} предоставя абстракция за състоянията. Те може да използват предоставените статични методи за 	
		изграждане на отделни елементи върху екрана. Моделите, също използват методи на \emph{UiFactory}, за да се изобразят и бъдат преместени.
		По този начин лесно може да сменим графичната библиотека, без това да налага промени по класове, отговорни за логиката на симулацията.